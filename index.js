/*!
 * HTMC - Hyper Text Markup Components
 * Copyright (c) 2024 Yagil Itzhak
 *
 * This library is licensed under the GNU General Public License v3.0
 * https://www.gnu.org/licenses/gpl-3.0.en.html
 */
"use strict"; class HTMCDefine extends HTMLElement { static registry = {}; static importedFiles = new Set; async connectedCallback() { await this.processImports(), this.defineComponents(), this.style.display = "none" } async processImports() { const e = Array.from(this.querySelectorAll("htmc-attach")); for (const t of e) { const e = t.getAttribute("src"); if (e && !HTMCDefine.importedFiles.has(e)) if (HTMCDefine.importedFiles.add(e), t.hasAttribute("defer")) window.addEventListener("load", (() => this.importComponents(e))); else if (t.hasAttribute("lazy")) { const n = new IntersectionObserver((t => { t.forEach((t => { t.isIntersecting && (this.importComponents(e), n.unobserve(t.target)) })) })); n.observe(t) } else await this.importComponents(e) } } async executeScripts(e) { for (const t of e) { const e = document.createElement("script"); Array.from(t.attributes).forEach((t => { e.setAttribute(t.name, t.value) })), e.textContent = t.textContent, t.replaceWith(e), e.src && await new Promise((t => e.addEventListener("load", t, { once: !0 }))) } } defineComponents() { const e = Array.from(this.getElementsByTagName("component")), t = Array.from(this.getElementsByTagName("script")); this.executeScripts(t); for (const t of e) { const e = t.getAttribute("attributes")?.split(" ") || [], n = t.getAttribute("name"); if (n && !customElements.get(n)) { const s = document.createElement("template"); s.innerHTML = t.innerHTML; const r = e.reduce(((e, t) => (e[t] = { value: "" }, e)), {}); HTMCDefine.registry[n] = { templateContent: s.content.cloneNode(!0), attributes: e, state: r }, customElements.define(n, class extends HTMLElement { shadow = this.attachShadow({ mode: "open" }); static get observedAttributes() { return HTMCDefine.registry[n].attributes } connectedCallback() { this.render() } attributeChangedCallback(e, t, n) { this.updateState(e, n), this.render() } render() { const e = HTMCDefine.registry[n]; if (!e) return; const t = e.templateContent.cloneNode(!0); this.replacePlaceholders(t, n), this.shadow.innerHTML = "", this.shadow.appendChild(t) } replacePlaceholders(e, t) { const n = HTMCDefine.registry[t].attributes; for (const s of n) { const n = HTMCDefine.registry[t].state[s], r = this.getAttribute(s) || n.value; e.querySelectorAll("*").forEach((e => { e.nodeType === Node.ELEMENT_NODE && (e.innerHTML = e.innerHTML.replace(new RegExp(`\\$\\{${s}\\}`, "g"), r)) })) } e.querySelectorAll("slot").forEach((e => { const t = e.getAttribute("name"); if (t) { const n = this.querySelector(`[slot="${t}"]`); n && e.appendChild(n.cloneNode(!0)) } })) } updateState(e, t) { const s = HTMCDefine.registry[n]?.state[e]; s && (s.value = t) } }) } } } async importComponents(e) { try { const t = await fetch(e); if (t.ok) { const e = await t.text(), n = document.createElement("template"); n.innerHTML = e, document.body.appendChild(n.content.cloneNode(!0)); n.content.querySelectorAll("htmc-attach").forEach((e => { const t = document.createElement("htmc-attach"); t.setAttribute("src", e.getAttribute("src")), e.hasAttribute("defer") && t.setAttribute("defer", ""), e.hasAttribute("lazy") && t.setAttribute("lazy", ""), document.body.appendChild(t) })) } } catch (e) { } } } customElements.define("htmc-define", HTMCDefine); class HTMCAttach extends HTMLElement { async connectedCallback() { const e = this.getAttribute("src"); if (e) if (this.hasAttribute("defer")) window.addEventListener("load", (() => HTMCDefine.prototype.importComponents(e))); else if (this.hasAttribute("lazy")) { const t = new IntersectionObserver((n => { for (const s of n) s.isIntersecting && (HTMCDefine.prototype.importComponents(e), t.unobserve(s.target)) })); t.observe(this) } else await HTMCDefine.prototype.importComponents(e) } } customElements.define("htmc-attach", HTMCAttach);
